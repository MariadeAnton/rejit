#include "dynasm/dasm_x86.h"

| .if X64

| .arch x64

| .define STR, rdi
| .define GR, rsi
| .define SAV, r11
| .define TMPB, r12b
| .define TMPD0, r12d
| .define TMPD1, edx
| .define TMPL, r12
| .define RET, rax
| .define SP, rsp
| .define TOS, qword [SP]

| .define RED_ZONE_SIZE, 128 // Number of bytes available in the red zone.

| .macro discard
| add SP, 8
| .endmacro

| .macro backup
| mov SAV, STR
| .endmacro

| .macro ubackup
| .endmacro

| .macro save
|| if (saved < RED_ZONE_SIZE/8) {
|      mov [rsp-8*(saved+1)], STR
||     needs_unsave = 0;
|| }
|| else {
|      push STR
||     needs_unsave = 1;
|| }
| .endmacro

| .macro gsave
|| if (needs_unsave)
|      mov STR, TOS
|| else
|      mov STR, [rsp-8*(saved+1)]
| .endmacro

| .macro rstsave
|| if (needs_unsave)
|       pop STR
|| else
|       mov STR, [rsp-8*(saved+1)]
| .endmacro

| .else

| .arch x86

| .define STR, edi
| .define GR, ebx
| .define SAV, TOS
| .define TMPB, dh
| .define TMPD0, edx
| .define TMPD1, ecx
| .define TMPL, edx
| .define RET, eax
| .define SP, esp
| .define TOS, dword [SP]

| .macro discard
| add SP, 4
| .endmacro

| .macro backup
| push STR
| .endmacro

| .macro ubackup
| discard
| .endmacro

| .macro save
|| needs_unsave = 1;
|  push STR
| .endmacro

| .macro gsave
|  mov STR, TOS
| .endmacro

| .macro rstsave
| pop STR
| .endmacro

| .endif

| .section code
| .globals lbl_
| .actionlist actions

| .define CONST, eax

| .macro unsave
|| if (needs_unsave)
|      discard
| .endmacro

| .type group, rejit_group

static void compile_prolog(dasm_State** Dst) {
    | .if not X64
    | mov STR, [esp+4]
    | mov GR, [esp+8]
    | .endif
    | backup
    | mov CONST, 1025
}

static void compile_epilog(dasm_State** Dst) {
    | mov RET, STR
    | sub RET, SAV
    | ubackup
    | ret
    |=>0:
    | mov RET, -1
    | ubackup
    | ret
}

static void compile_one(dasm_State** Dst, rejit_instruction* instr, int* errpc,
    int* pcl, int saved) {
    rejit_instruction* ia, *ib, *ic;
    unsigned long magic;
    char min, *s;
    int ebk = *errpc, bk, i, needs_unsave;
    size_t len;
    if (instr->kind > RJ_ISKIP) return;
    switch (instr->kind) {
    case RJ_ISKIP: printf("RJ_ISKIP was added to RJ_INULL\n"); abort();
    case RJ_IWORD:
        s = (char*)instr->value;
        len = strlen(s);
        for (i=0; i<len; ++i) {
            | cmp byte [STR+i], s[i]
            | jne =>*errpc
        }
        | add STR, len
        break;
    case RJ_ISTAR:
    case RJ_IPLUS:
    case RJ_IOPT:
        ia = instr+1;
        if (instr->kind == RJ_IPLUS) compile_one(Dst, ia, errpc, pcl, saved);
        *errpc = *pcl;
        GROW;
        bk = *pcl;
        GROW;
        if (instr->kind != RJ_IOPT)
            |=>bk:
        if (instr->kind == RJ_IPLUS) unskip(ia);
        compile_one(Dst, ia, errpc, pcl, saved);
        if (instr->kind != RJ_IOPT) {
            // Without the braces here, DynAsm generates incorrect code.
            | jmp =>bk
        }
        |=>*errpc:
        skip(ia);
        break;
    case RJ_IMSTAR:
    case RJ_IMPLUS:
        ia = instr+1;
        bk = *pcl;
        GROW;
        if (instr->kind == RJ_IMSTAR) {
            GROW;
            | jmp =>bk+1
        }
        |=>bk:
        compile_one(Dst, ia, errpc, pcl, saved);
        skip(ia);
        if (instr->kind == RJ_IMSTAR)
            |=>bk+1:
        *errpc = bk;
        break;
    case RJ_IDOT:
        | movzx TMPD0, byte [STR]
        | bt CONST, TMPD0
        | jb =>*errpc
        | inc STR
        break;
    case RJ_IBEGIN:
        | cmp SAV, STR
        | jne =>*errpc
        break;
    case RJ_IEND:
        | cmp byte [STR], 0
        | jne =>*errpc
        break;
    case RJ_ISET:
        s = (char*)instr->value;
        magic = genmagic(s, &min, &len);
        GROW;
        for (i=len+1; i<len*2+1; ++i) if (!s[i]) {
            | cmp byte [STR], s[i-len-1]
            | je =>*pcl-1
        }
        | mov TMPD0, magic
        | movzx TMPD1, byte [STR]
        | sub TMPD1, min
        | js =>*errpc
        | bt TMPD0, TMPD1
        | jae =>*errpc
        | =>*pcl-1:
        | inc STR
        break;
    case RJ_IOR:
        ia = instr+1;
        ib = (rejit_instruction*)instr->value;
        ic = (rejit_instruction*)instr->value2;
        | save
        *errpc = *pcl;
        GROW;
        GROW;
        bk = *pcl-1;
        if (needs_unsave) GROW;
        for (; ia != ib; ++ia) {
            compile_one(Dst, ia, errpc, pcl, saved+1);
            skip(ia);
        }
        | jmp =>bk
        |=>*errpc:
        | gsave
        *errpc = needs_unsave ? bk+1 : ebk;
        for (; ia != ic; ++ia) {
            compile_one(Dst, ia, errpc, pcl, saved+1);
            skip(ia);
        }
        *errpc = ebk;
        if (needs_unsave) {
            | jmp =>bk
            |=>bk+1:
            | rstsave
            | jmp =>*errpc
        }
        |=>bk:
        | unsave
        break;
    case RJ_ICGROUP:
    case RJ_IGROUP:
        *errpc = bk = *pcl;
        GROW;
        GROW;
        | save
        for (ia = instr+1; ia != (rejit_instruction*)instr->value; ++ia) {
            compile_one(Dst, ia, errpc, pcl, saved+1);
            skip(ia);
        }
        *errpc = ebk;
        | jmp =>bk+1
        |=>bk:
        | rstsave
        | jmp =>*errpc
        |=>bk+1:
        if (instr->kind == RJ_ICGROUP) {
            if (needs_unsave)
                | mov TMPL, TOS
            else
                | .if X64
                | mov TMPL, [SP-8*(saved+1)]
                | .else
                || printf("needs_unsave should be true on X86\n"); abort();
                | .endif
        }

        if (needs_unsave)
            | unsave

        if (instr->kind == RJ_ICGROUP) {
            | mov group:GR[instr->value2].begin, TMPL
            | mov group:GR[instr->value2].end, STR
        }
        break;
    default: printf("unrecognized opcode: %d\n", instr->kind); abort();
    };
    if (instr->kind != RJ_IMSTAR && instr->kind != RJ_IMPLUS) *errpc = ebk;
}
